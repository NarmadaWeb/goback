package database

import (
	"context"
	"database/sql"
	"errors"
	"time"

	"{{.ModulePath}}/domain"
	"{{.ModulePath}}/ports"

	{{- if eq .Database "postgresql" }}
	"github.com/google/uuid"
	{{- end}}
	
	{{- if eq .Tool "gorm" }}
	"gorm.io/gorm"
	{{- else if eq .Tool "sqlx" }}
	"github.com/jmoiron/sqlx"
	{{- else if eq .Tool "sqlc" }}
	"{{.ModulePath}}/adapters/secondary/database/sqlc" // Assuming sqlc generated package
	{{- end}}
)

// --- PERSISTENCE MODEL & MAPPING ---
type UserPersistenceModel struct {
	{{- if and (eq .Tool "gorm") (ne .Database "postgresql") }}
	gorm.Model
	{{- else if and (eq .Tool "gorm") (eq .Database "postgresql") }}
	ID        uuid.UUID `gorm:"type:uuid;primary_key"`
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt gorm.DeletedAt `gorm:"index"`
	{{- else }}
		{{- if eq .Database "postgresql" }}
	ID        uuid.UUID `db:"id"`
		{{- else}}
	ID        uint      `db:"id"`
		{{- end}}
	CreatedAt time.Time `db:"created_at"`
	UpdatedAt time.Time `db:"updated_at"`
	{{- end}}

	Name      string    `{{if eq .Tool "gorm"}}{{else}}db:"name"{{end}}`
	Email     string    `{{if eq .Tool "gorm"}}gorm:"uniqueIndex"{{else}}db:"email"{{end}}`
	Password  string    `{{if eq .Tool "gorm"}}{{else}}db:"password"{{end}}`
	IsActive  bool      `{{if eq .Tool "gorm"}}{{else}}db:"is_active"{{end}}`
}

{{ if eq .Tool "gorm" }}
func (UserPersistenceModel) TableName() string { return "users" }
{{ end }}

// Mapping functions
func toDomain(p *UserPersistenceModel) *domain.User {
	d := &domain.User{
		Name:      p.Name,
		Email:     p.Email,
		Password:  p.Password,
		IsActive:  p.IsActive,
	}
	{{- if and (eq .Tool "gorm") (ne .Database "postgresql") }}
	d.ID = p.ID
	d.CreatedAt = p.CreatedAt
	d.UpdatedAt = p.UpdatedAt
	{{- else }}
	d.ID = p.ID
	d.CreatedAt = p.CreatedAt
	d.UpdatedAt = p.UpdatedAt
	{{- end}}
	return d
}

func fromDomain(d *domain.User) *UserPersistenceModel {
	p := &UserPersistenceModel{
		Name:      d.Name,
		Email:     d.Email,
		Password:  d.Password,
		IsActive:  d.IsActive,
	}
	p.ID = d.ID

	{{ if ne .Tool "gorm" }}
	p.CreatedAt = d.CreatedAt
	p.UpdatedAt = d.UpdatedAt
	{{ end }}
	return p
}

{{/* =================== GORM IMPLEMENTATION =================== */}}
{{ if eq .Tool "gorm" }}
type GormUserRepository struct { 
	db *gorm.DB 
}

func NewGormUserRepository(db *gorm.DB) ports.UserRepository { 
	return &GormUserRepository{db: db} 
}

func (r *GormUserRepository) Create(user *domain.User) error {
	model := fromDomain(user)
	result := r.db.Create(model)
	if result.Error != nil {
		return result.Error
	}
	user.ID = model.ID
	return nil
}

{{- if eq .Database "postgresql" }}
func (r *GormUserRepository) GetByID(id uuid.UUID) (*domain.User, error) {
{{- else}}
func (r *GormUserRepository) GetByID(id uint) (*domain.User, error) {
{{- end}}
	var model UserPersistenceModel
	result := r.db.First(&model, id)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, result.Error
	}
	return toDomain(&model), nil
}

func (r *GormUserRepository) GetByEmail(email string) (*domain.User, error) {
	var model UserPersistenceModel
	result := r.db.Where("email = ?", email).First(&model)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, result.Error
	}
	return toDomain(&model), nil
}

func (r *GormUserRepository) GetAll(page, perPage int) ([]*domain.User, int64, error) {
	var models []UserPersistenceModel
	var total int64
	
	r.db.Model(&UserPersistenceModel{}).Count(&total)
	
	offset := (page - 1) * perPage
	result := r.db.Offset(offset).Limit(perPage).Find(&models)
	if result.Error != nil {
		return nil, 0, result.Error
	}
	
	users := make([]*domain.User, len(models))
	for i, model := range models {
		users[i] = toDomain(&model)
	}
	
	return users, total, nil
}

{{- if eq .Database "postgresql" }}
func (r *GormUserRepository) Update(id uuid.UUID, user *domain.User) error {
{{- else}}
func (r *GormUserRepository) Update(id uint, user *domain.User) error {
{{- end}}
	model := fromDomain(user)
	model.ID = id // Ensure the ID is set for the update
	return r.db.Save(model).Error
}

{{- if eq .Database "postgresql" }}
func (r *GormUserRepository) Delete(id uuid.UUID) error {
{{- else}}
func (r *GormUserRepository) Delete(id uint) error {
{{- end}}
	return r.db.Delete(&UserPersistenceModel{}, id).Error
}

func (r *GormUserRepository) Search(query string, page, perPage int) ([]*domain.User, int64, error) {
	// Implement search logic for GORM
	return r.GetAll(page, perPage) // Placeholder
}

func (r *GormUserRepository) ExistsByEmail(email string) (bool, error) {
	var count int64
	r.db.Model(&UserPersistenceModel{}).Where("email = ?", email).Count(&count)
	return count > 0, nil
}
{{ end }}


{{/* =================== SQLX IMPLEMENTATION =================== */}}
{{ if eq .Tool "sqlx" }}
type SqlxUserRepository struct { 
	db *sqlx.DB 
}

func NewSqlxUserRepository(db *sqlx.DB) ports.UserRepository { 
	return &SqlxUserRepository{db: db} 
}

func (r *SqlxUserRepository) Create(user *domain.User) error {
	model := fromDomain(user)
	query := `INSERT INTO users (name, email, password, is_active, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id`
	return r.db.QueryRowx(query, model.Name, model.Email, model.Password, model.IsActive, model.CreatedAt, model.UpdatedAt).Scan(&user.ID)
}

{{- if eq .Database "postgresql" }}
func (r *SqlxUserRepository) GetByID(id uuid.UUID) (*domain.User, error) {
{{- else}}
func (r *SqlxUserRepository) GetByID(id uint) (*domain.User, error) {
{{- end}}
	var model UserPersistenceModel
	err := r.db.Get(&model, "SELECT * FROM users WHERE id=$1", id)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	return toDomain(&model), nil
}

func (r *SqlxUserRepository) GetByEmail(email string) (*domain.User, error) {
	var model UserPersistenceModel
	err := r.db.Get(&model, "SELECT * FROM users WHERE email=$1", email)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	return toDomain(&model), nil
}

func (r *SqlxUserRepository) GetAll(page, perPage int) ([]*domain.User, int64, error) {
	var models []UserPersistenceModel
	var total int64
	
	r.db.Get(&total, "SELECT COUNT(*) FROM users")
	
	offset := (page - 1) * perPage
	err := r.db.Select(&models, "SELECT * FROM users LIMIT $1 OFFSET $2", perPage, offset)
	if err != nil {
		return nil, 0, err
	}
	
	users := make([]*domain.User, len(models))
	for i, model := range models {
		users[i] = toDomain(&model)
	}
	
	return users, total, nil
}

{{- if eq .Database "postgresql" }}
func (r *SqlxUserRepository) Update(id uuid.UUID, user *domain.User) error {
{{- else}}
func (r *SqlxUserRepository) Update(id uint, user *domain.User) error {
{{- end}}
	model := fromDomain(user)
	_, err := r.db.NamedExec(`UPDATE users SET name=:name, email=:email, password=:password, is_active=:is_active, updated_at=:updated_at WHERE id=:id`, model)
	return err
}

{{- if eq .Database "postgresql" }}
func (r *SqlxUserRepository) Delete(id uuid.UUID) error {
{{- else}}
func (r *SqlxUserRepository) Delete(id uint) error {
{{- end}}
	_, err := r.db.Exec("DELETE FROM users WHERE id=$1", id)
	return err
}

func (r *SqlxUserRepository) Search(query string, page, perPage int) ([]*domain.User, int64, error) {
	// Implement search logic for SQLX
	return r.GetAll(page, perPage) // Placeholder
}

func (r *SqlxUserRepository) ExistsByEmail(email string) (bool, error) {
	var exists bool
	err := r.db.Get(&exists, "SELECT EXISTS(SELECT 1 FROM users WHERE email=$1)", email)
	return exists, err
}
{{ end }}


{{/* =================== SQLC IMPLEMENTATION =================== */}}
{{ if eq .Tool "sqlc" }}
type SqlcUserRepository struct { 
	queries *sqlc.Queries 
}

func NewSqlcUserRepository(db *sql.DB) ports.UserRepository { 
	return &SqlcUserRepository{queries: sqlc.New(db)} 
}

func (r *SqlcUserRepository) Create(user *domain.User) error {
	model := fromDomain(user)
	params := sqlc.CreateUserParams{
		Name:      model.Name,
		Email:     model.Email,
		Password:  model.Password,
		IsActive:  model.IsActive,
		CreatedAt: model.CreatedAt,
		UpdatedAt: model.UpdatedAt,
	}
	createdUser, err := r.queries.CreateUser(context.Background(), params)
	if err != nil {
		return err
	}
	user.ID = createdUser.ID
	return nil
}

{{- if eq .Database "postgresql" }}
func (r *SqlxUserRepository) GetByID(id uuid.UUID) (*domain.User, error) {
{{- else}}
func (r *SqlcUserRepository) GetByID(id uint) (*domain.User, error) {
{{- end}}
	user, err := r.queries.GetUser(context.Background(), id)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	return toDomain(&UserPersistenceModel{
		ID: user.ID,
		Name: user.Name,
		Email: user.Email,
		Password: user.Password,
		IsActive: user.IsActive,
		CreatedAt: user.CreatedAt,
		UpdatedAt: user.UpdatedAt,
	}), nil
}

func (r *SqlcUserRepository) GetByEmail(email string) (*domain.User, error) {
	// Assuming GetUserByEmail exists in your sqlc queries
	return nil, errors.New("not implemented")
}

func (r *SqlcUserRepository) GetAll(page, perPage int) ([]*domain.User, int64, error) {
	// Assuming ListUsers and CountUsers exist in your sqlc queries
	return nil, 0, errors.New("not implemented")
}

{{- if eq .Database "postgresql" }}
func (r *SqlcUserRepository) Update(id uuid.UUID, user *domain.User) error {
{{- else}}
func (r *SqlcUserRepository) Update(id uint, user *domain.User) error {
{{- end}}
	params := sqlc.UpdateUserParams{
		ID: id,
		Name: user.Name,
		Email: user.Email,
		Password: user.Password,
		IsActive: user.IsActive,
		UpdatedAt: time.Now(),
	}
	return r.queries.UpdateUser(context.Background(), params)
}

{{- if eq .Database "postgresql" }}
func (r *SqlcUserRepository) Delete(id uuid.UUID) error {
{{- else}}
func (r *SqlcUserRepository) Delete(id uint) error {
{{- end}}
	return r.queries.DeleteUser(context.Background(), id)
}

func (r *SqlcUserRepository) Search(query string, page, perPage int) ([]*domain.User, int64, error) {
	// Implement search logic for SQLC
	return nil, 0, errors.New("not implemented")
}

func (r *SqlcUserRepository) ExistsByEmail(email string) (bool, error) {
	// Assuming CountUsersByEmail exists in your sqlc queries
	return false, errors.New("not implemented")
}
{{ end }}
