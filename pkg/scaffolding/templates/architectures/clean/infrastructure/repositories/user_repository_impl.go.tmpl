package repositories

import (
	"context"
	"errors"
	"time"

	"{{.ModulePath}}/domain/entities"
	"{{.ModulePath}}/domain/usecases"
	
	{{- if eq .Database "postgresql" }}
	"github.com/google/uuid"
	{{- end}}
	
	{{- if eq .Tool "gorm" }}
	"gorm.io/gorm"
	{{- else if eq .Tool "sqlx" }}
	"github.com/jmoiron/sqlx"
	{{- else if eq .Tool "sqlc" }}
	"{{.ModulePath}}/infrastructure/database/sqlc" // Assuming sqlc generated package
	{{- end}}
)

// Persistence model for database, separate from domain entity.
type UserPersistenceModel struct {
	{{- if eq .Database "postgresql" }}
	ID        uuid.UUID `{{if eq .Tool "gorm"}}gorm:"type:uuid;primary_key"{{else}}db:"id"{{end}}`
	{{- else}}
	ID        uint      `{{if eq .Tool "gorm"}}gorm:"primary_key;autoIncrement"{{else}}db:"id"{{end}}`
	{{- end}}
	Name      string    `{{if eq .Tool "gorm"}}{{else}}db:"name"{{end}}`
	Email     string    `{{if eq .Tool "gorm"}}gorm:"uniqueIndex"{{else}}db:"email"{{end}}`
	Password  string    `{{if eq .Tool "gorm"}}{{else}}db:"password"{{end}}`
	IsActive  bool      `{{if eq .Tool "gorm"}}{{else}}db:"is_active"{{end}}`
	CreatedAt time.Time `{{if eq .Tool "gorm"}}{{else}}db:"created_at"{{end}}`
	UpdatedAt time.Time `{{if eq .Tool "gorm"}}{{else}}db:"updated_at"{{end}}`
}

{{ if eq .Tool "gorm" }}
func (UserPersistenceModel) TableName() string { return "users" }
{{ end }}

// Mapping functions
func toEntity(p *UserPersistenceModel) *entities.User {
	{{- if eq .Database "postgresql" }}
	return &entities.User{
		ID:        p.ID,
		Name:      p.Name,
		Email:     p.Email,
		Password:  p.Password,
		IsActive:  p.IsActive,
		CreatedAt: p.CreatedAt,
		UpdatedAt: p.UpdatedAt,
	}
	{{- else}}
	return &entities.User{
		ID:        entities.UserID(p.ID),
		Name:      p.Name,
		Email:     p.Email,
		Password:  p.Password,
		IsActive:  p.IsActive,
		CreatedAt: p.CreatedAt,
		UpdatedAt: p.UpdatedAt,
	}
	{{- end}}
}

func fromEntity(e *entities.User) *UserPersistenceModel {
	{{- if eq .Database "postgresql" }}
	id, _ := e.ID.(uuid.UUID)
	return &UserPersistenceModel{
		ID:        id,
		Name:      e.Name,
		Email:     e.Email,
		Password:  e.Password,
		IsActive:  e.IsActive,
		CreatedAt: e.CreatedAt,
		UpdatedAt: e.UpdatedAt,
	}
	{{- else}}
	id, _ := e.ID.(int)
	return &UserPersistenceModel{
		ID:        uint(id),
		Name:      e.Name,
		Email:     e.Email,
		Password:  e.Password,
		IsActive:  e.IsActive,
		CreatedAt: e.CreatedAt,
		UpdatedAt: e.UpdatedAt,
	}
	{{- end}}
}

{{/* =================== GORM IMPLEMENTATION =================== */}}
{{ if eq .Tool "gorm" }}
type GormUserRepository struct { 
	db *gorm.DB 
}

func NewGormUserRepository(db *gorm.DB) usecases.UserRepository { 
	return &GormUserRepository{db: db} 
}

func (r *GormUserRepository) Create(ctx context.Context, user *entities.User) error {
	model := fromEntity(user)
	result := r.db.WithContext(ctx).Create(model)
	if result.Error != nil {
		return result.Error
	}
	user.ID = entities.UserID(model.ID)
	return nil
}

func (r *GormUserRepository) GetByID(ctx context.Context, id entities.UserID) (*entities.User, error) {
	var model UserPersistenceModel
	result := r.db.WithContext(ctx).First(&model, id)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, result.Error
	}
	return toEntity(&model), nil
}

func (r *GormUserRepository) GetAll(ctx context.Context, page, perPage int) ([]*entities.User, int64, error) {
	var models []UserPersistenceModel
	var total int64
	
	r.db.Model(&UserPersistenceModel{}).Count(&total)
	
	offset := (page - 1) * perPage
	result := r.db.WithContext(ctx).Offset(offset).Limit(perPage).Find(&models)
	if result.Error != nil {
		return nil, 0, result.Error
	}
	
	users := make([]*entities.User, len(models))
	for i, model := range models {
		users[i] = toEntity(&model)
	}
	
	return users, total, nil
}

func (r *GormUserRepository) Update(ctx context.Context, user *entities.User) error {
	model := fromEntity(user)
	return r.db.WithContext(ctx).Save(model).Error
}

func (r *GormUserRepository) Delete(ctx context.Context, id entities.UserID) error {
	return r.db.WithContext(ctx).Delete(&UserPersistenceModel{}, id).Error
}
{{ end }}

{{/* =================== SQLX AND SQLC IMPLEMENTATIONS (abbreviated) =================== */}}
{{ if eq .Tool "sqlx" }}
type SqlxUserRepository struct { db *sqlx.DB }
func NewSqlxUserRepository(db *sqlx.DB) usecases.UserRepository { return &SqlxUserRepository{db: db} }
// ... methods for SQLX ...
{{ end }}
{{ if eq .Tool "sqlc" }}
type SqlcUserRepository struct { queries *sqlc.Queries }
func NewSqlcUserRepository(db *sql.DB) usecases.UserRepository { return &SqlcUserRepository{queries: sqlc.New(db)} }
// ... methods for SQLC ...
{{ end }}
