package repositories

import (
	"context"
	"errors"
	"time"

	"{{.ModulePath}}/domain/entities"
	"{{.ModulePath}}/domain/usecases"
	
	{{- if eq .Database "postgresql" }}
	"github.com/google/uuid"
	{{- end}}
	
	{{- if eq .Tool "gorm" }}
	"gorm.io/gorm"
	{{- else if eq .Tool "sqlx" }}
	"github.com/jmoiron/sqlx"
	{{- else if eq .Tool "sqlc" }}
	"{{.ModulePath}}/infrastructure/database/sqlc" // Assuming sqlc generated package
	{{- end}}
)

// Persistence model for database, separate from domain entity.
type UserPersistenceModel struct {
	{{- if and (eq .Tool "gorm") (ne .Database "postgresql") }}
	gorm.Model
	{{- else if and (eq .Tool "gorm") (eq .Database "postgresql") }}
	ID        uuid.UUID `gorm:"type:uuid;primary_key"`
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt gorm.DeletedAt `gorm:"index"`
	{{- else }}
		{{- if eq .Database "postgresql" }}
	ID        uuid.UUID `db:"id"`
		{{- else}}
	ID        uint      `db:"id"`
		{{- end}}
	CreatedAt time.Time `db:"created_at"`
	UpdatedAt time.Time `db:"updated_at"`
	{{- end}}

	Name      string    `{{if eq .Tool "gorm"}}{{else}}db:"name"{{end}}`
	Email     string    `{{if eq .Tool "gorm"}}gorm:"uniqueIndex"{{else}}db:"email"{{end}}`
	Password  string    `{{if eq .Tool "gorm"}}{{else}}db:"password"{{end}}`
	IsActive  bool      `{{if eq .Tool "gorm"}}{{else}}db:"is_active"{{end}}`
}

{{ if eq .Tool "gorm" }}
func (UserPersistenceModel) TableName() string { return "users" }
{{ end }}

// Mapping functions
func toEntity(p *UserPersistenceModel) *entities.User {
	var userID entities.UserID
	var createdAt, updatedAt time.Time

	{{- if and (eq .Tool "gorm") (ne .Database "postgresql") }}
	userID = entities.UserID(p.ID)
	createdAt = p.CreatedAt
	updatedAt = p.UpdatedAt
	{{- else }}
	userID = p.ID
	createdAt = p.CreatedAt
	updatedAt = p.UpdatedAt
	{{- end}}

	return &entities.User{
		ID:        userID,
		Name:      p.Name,
		Email:     p.Email,
		Password:  p.Password,
		IsActive:  p.IsActive,
		CreatedAt: createdAt,
		UpdatedAt: updatedAt,
	}
}

func fromEntity(e *entities.User) *UserPersistenceModel {
	p := &UserPersistenceModel{
		Name:      e.Name,
		Email:     e.Email,
		Password:  e.Password,
		IsActive:  e.IsActive,
	}
	p.ID = e.ID
	
	{{ if ne .Tool "gorm" }}
	p.CreatedAt = e.CreatedAt
	p.UpdatedAt = e.UpdatedAt
	{{ end }}

	return p
}

{{/* =================== GORM IMPLEMENTATION =================== */}}
{{ if eq .Tool "gorm" }}
type GormUserRepository struct { 
	db *gorm.DB 
}

func NewGormUserRepository(db *gorm.DB) usecases.UserRepository { 
	return &GormUserRepository{db: db} 
}

func (r *GormUserRepository) Create(ctx context.Context, user *entities.User) error {
	model := fromEntity(user)
	result := r.db.WithContext(ctx).Create(model)
	if result.Error != nil {
		return result.Error
	}
	user.ID = entities.UserID(model.ID)
	return nil
}

func (r *GormUserRepository) GetByID(ctx context.Context, id entities.UserID) (*entities.User, error) {
	var model UserPersistenceModel
	result := r.db.WithContext(ctx).First(&model, id)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, result.Error
	}
	return toEntity(&model), nil
}

func (r *GormUserRepository) GetAll(ctx context.Context, page, perPage int) ([]*entities.User, int64, error) {
	var models []UserPersistenceModel
	var total int64
	
	r.db.Model(&UserPersistenceModel{}).Count(&total)
	
	offset := (page - 1) * perPage
	result := r.db.WithContext(ctx).Offset(offset).Limit(perPage).Find(&models)
	if result.Error != nil {
		return nil, 0, result.Error
	}
	
	users := make([]*entities.User, len(models))
	for i, model := range models {
		users[i] = toEntity(&model)
	}
	
	return users, total, nil
}

func (r *GormUserRepository) Update(ctx context.Context, user *entities.User) error {
	model := fromEntity(user)
	return r.db.WithContext(ctx).Save(model).Error
}

func (r *GormUserRepository) Delete(ctx context.Context, id entities.UserID) error {
	return r.db.WithContext(ctx).Delete(&UserPersistenceModel{}, id).Error
}
{{ end }}

{{/* =================== SQLX AND SQLC IMPLEMENTATIONS (abbreviated) =================== */}}
{{ if eq .Tool "sqlx" }}
type SqlxUserRepository struct { db *sqlx.DB }
func NewSqlxUserRepository(db *sqlx.DB) usecases.UserRepository { return &SqlxUserRepository{db: db} }
// ... methods for SQLX ...
{{ end }}
{{ if eq .Tool "sqlc" }}
type SqlcUserRepository struct { queries *sqlc.Queries }
func NewSqlcUserRepository(db *sql.DB) usecases.UserRepository { return &SqlcUserRepository{queries: sqlc.New(db)} }
// ... methods for SQLC ...
{{ end }}
